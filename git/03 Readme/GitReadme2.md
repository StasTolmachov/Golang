ИНСТРУКЦИЯ

## 1. Команды git
*****************
### Идентификатор
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com


### Установка, инициализация
* git init - создание локального репозитория;
* git clone [url] - получение копии существующего репозитария с сервера.


### Внесение изменений в репозиторий
* git status - состояние репозитория;
* git add [file] - отслеживать добавленный файл;
* git reset [file] - отмена индексирования; git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было;
* git revert - отменить изменения и поделиться отменёнными изменениями с остальными (для удаленных веток) ;
* git cherry-pick <Commit1> <Commit2> <...>;
* git diff - разница между текущим файлом и сохранненным, но не проиндексировано;
* git diff --staged - сравнение индексированных изменений с содержимым последней зафиксированной версии;
* commit -m "message"- зафиксировать и сохранить с указанным сообщением;
* git commit –amend - отмена внесенных изменений (повторное сохранение версии с заменой коммитом результата предыдущей фиксации);
* git commit -a - Выполнение коммита состояния со всеми изменениями в рабочем каталоге. Эта команда включает только изменения отслеживаемых файлов


### Ветвление
* git branch - вывод на экран списка веток, создание новых, а также удаление и переименование;
*git branch -d имя_ветки   удаление*
  например, git branch -f main HEAD~3 переместит (принудительно) ветку main на три родителя назад от HEAD.

* git checkout - переключения между версиями (коммитами);
       git checkout -b имя_ветки - создание с переходом на новую ветку*;
* git merge - вставка содержимого одной или нескольких веток в ту ветку, в которой вы в данный момент находитесь;
* git log - журнал изменений;
### Информация об объекте
* git log - выводит в обратном хронологическом порядке список сохраненных в данный репозиторий версий (то есть первыми показываются самые свежие коммиты);
* git log branchB..branchA - показать коммиты в branchA, которых нет в BranchB;
* git log --follow [file] - выводит коммиты, которые изменили файл, даже при переименовании;
* git diff branchB...branchA - показывает разницу в том, что находится в branchA, чего нет в BranchB;
* git show [SHA] - просмотра данных тега вместе с помеченным им коммитом;


### Отслеживание изменений
* git rm [file] - удалить файл из числа отслеживаемых (убрать из области индексирования) и зафиксировать данное изменение (чтобы удалить файл как из репозитория, так и из локальной файловой системы.);
     git rm с параметром --cached, чтобы удалить этот файл из репозитория, но оставить его в рабочем каталоге как игнорируемый файл.
* git mv [existing-path] [new-path] - переименованиe файла;
* git log --stat - отображает под записью о каждой версии список измененных файлов, их количество, а также количество добавленных в них и удаленных из них строк и в конце выводит сводную информацию;


### Игнорирование файлов
*.gitignore *со списком соответствующих паттернов* - класс файлов которые вы не хотите ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых
# ignore all logs  *.log  - символ #, чтобы добавить в файл .gitignore комментарии

•	git check-ignore с параметром -v (или --verbose), чтобы определить, какой шаблон приводит к игнорированию конкретного файла:

### Обновление локальных репозиториев
* git remote add [alias] [url] - добавление удаленного репозитория;
* git fetch [alias] - извлечение данных из удаленных проектов;
* git merge [alias]/[branch] - объединение удаленной ветки с текущей веткой, чтобы обновить ее;
* git push - отправка данных в удаленный репозиторий;
* git pull - извлечение информации из указанного удаленного репозитория, и вставка ее в текущую ветку;

git pull, является аналогом и более кратким аналогом для совместных fetch и merge.
 git pull --rebase - аналог для совместно вызванных fetch и rebase!



### Временное хранение измененных файлов
* git stash -  перейти в другую ветку, не фиксируя результатов своей работы (спрятать все в буфер);
* git stash list - увидеть содержимое стека;
* git stash pop - возвращает сохраненную в буфере информацию в ветку и немедленно удаляет ее из буфера; 
* git stash drop - удаление фрагмента из стека
   git stash с параметром -u (или --include-untracked) позволяет отложить неотслеживаемые файлы:
   git stash с параметром --all, чтобы создать отложенные изменения также для игнорируемых и неотслеживаемых файлов.

Псевдонимы
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status

## Работа с публичным репозиторием
1. Создать аккаунт на GitHub. Если у вас этого нет, запишем полный адрес GitHub.com.
2. Создать локальный репозиторий. Это должны сделать вы. Для этого надо создать папку,
внутри неё вызвать команду git init, совершить какие-то действия, создать файлы, чтобы
появился хотя бы один коммит.
3. «Подружить» ваш локальный и удалённый репозитории. GitHub при создании нового
репозитория подскажет, как это можно сделать.
4. Отправить (push) ваш локальный репозиторий в удалённый (на GitHub), при этом вам,
возможно, потребуется авторизоваться на удалённом репозитории. Если сделаете это
один раз, «подружите» ваш редактор VS Code с GitHub, в дальнейшем эту операцию
проводить уже не понадобится.
5. Провести изменения «с другого компьютера». Естественно, не надо искать другой
компьютер. Можете сделать это на GitHub, как сделали мы.
6. Выкачать (pull) актуальное состояние из удалённого репозитория.
участие в общественном проекте именно через систему pull request.

### Создание кнопки pull request
1. Делаем форк (fork) интересующего нас репозитория.
2. Делаем git clone для нашей версии этого репозитория. Так появляется версия на нашем
аккаунте, и именно эту версию мы клонируем.
3. Создаём ветку с предлагаемыми изменениями.
4. Производим все изменения только в этой ветке.
5. Отправляем эти изменения на свой аккаунт (push).
6. В окне на GitHub появляется возможность отправить pull request.

==========================
## 2.Редактор Markdown
### Текст
Альтернативные способы выделения текста жирным или курсивом нужны для того чтобы мы могли совмещать оба этих способа. Наример, _текст может быть выделен курсивом и при этом быть **полужирным**_...

Альтернативные способы выделения текста жирным или курсивом нужны для того чтобы мы могли совмещать оба этих способа. Наример, _текст может быть выделен курсивом и при этом быть **полужирным**_.


*Курсив* и _Курсив_
**Жирный текст** и __Жирный текст__
***Жирный и курсивный текст***


# Заголовок H1
## Заголовок H2
### Заголовок H3

Горизонтальные линии:
     ***
     ---
     ___ 

  ~~Зачёркнутый текст.~~
- [ ] Невыполненная задача
- [X] Выполненная задача



### Списки
Чтобы добавить ненумерованные списки, необходимо  пункты выделить (*) или знаком +.Например, вот так
* Элемент 1
* Элемент 2
* Элемент 3

Чтобы добавить нумерованные списки, необходимо  пункты просто пронумеровать.Например, вот так
1. Первый пункт
2. Второй пункт


### Работа с изображениями
Чтобы вставить изображение в текст, достаточно написать следующее ![подпись](ссылка_на_изображение):
![Привет!](15.jpg)


### Сcылки
1. Гиперссылка, с немедленным указанием адреса (внутритекстовая):
 необходимо использовать круглые скобки сразу после закрывающей квадратной. Внутри них необходимо поместить URL-адрес. В них же возможно расположить название, заключенное в кавычки, которое будет отображаться при наведении (необязательно):
[пример](http://example.com/ "Необязательная подсказка")
*в результате на экран выводится следующее: пример*
2. Гиперссылка, подобная сноскe: [заголовок_ссылки](сама_ссылка):
[Лайфхакер](lifehacker.ru)

### Таблицы
Для таблиц используйте символы | и -
| раз | два | три |
|:----|:----|:----|
| раз | два | три |

### Цитаты
 Чтобы отобразить цитату необходимо знак > проставлять перед каждой строчкой цитаты.  Например,
> Очень глубокомысленная цитата. Пожалуйста, прочтите её внимательно.
>
> Оскар Уайльд

### Заключение
Главной особенностью данного языка является максимально простой синтаксис, который служит для упрощения написания и чтения кода разметки, что, в свою очередь, позволяет легко его корректировать